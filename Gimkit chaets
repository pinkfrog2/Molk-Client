here is the code
// ==UserScript==
// @name        gimkit cheats (MOD MENU)
// @description A userscript gives you a mod menu to cheat in gimkit!
// @namespace   https://www.github.com/GimkitCheat
// @match       https://www.gimkit.com/join*
// @run-at      document-start
// @iconURL     https://www.gimkit.com/favicon.png
// @author      Rylan Rude Staff:Colton,Enick
// @version     0.3.7
// @license     ISC
// @grant       GM_getValue
// @grant       GM_setValue
// @grant       GM_deleteValue
// ==/UserScript==
(function () {
  'use strict';
 
  var version = "0.3.7";
 
  function utf8Read$1(bytes, offset, length) {
  	var string = '', chr = 0;
  	for (var i = offset, end = offset + length; i < end; i++) {
  		var byte = bytes[i];
  		if ((byte & 0x80) === 0x00) {
  			string += String.fromCharCode(byte);
  			continue;
  		}
  		if ((byte & 0xe0) === 0xc0) {
  			string += String.fromCharCode(
  				((byte & 0x1f) << 6) |
  				(bytes[++i] & 0x3f)
  			);
  			continue;
  		}
  		if ((byte & 0xf0) === 0xe0) {
  			string += String.fromCharCode(
  				((byte & 0x0f) << 12) |
  				((bytes[++i] & 0x3f) << 6) |
  				((bytes[++i] & 0x3f) << 0)
  			);
  			continue;
  		}
  		if ((byte & 0xf8) === 0xf0) {
  			chr = ((byte & 0x07) << 18) |
  				((bytes[++i] & 0x3f) << 12) |
  				((bytes[++i] & 0x3f) << 6) |
  				((bytes[++i] & 0x3f) << 0);
  			if (chr >= 0x010000) { // surrogate pair
  				chr -= 0x010000;
  				string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
  			} else {
  				string += String.fromCharCode(chr);
  			}
  			continue;
  		}
 
  		console.error('Invalid byte ' + byte.toString(16));
  		// (do not throw error to avoid server/client from crashing due to hack attemps)
  		// throw new Error('Invalid byte ' + byte.toString(16));
  	}
  	return string;
  }
 
  function int8(bytes, it) {
  	return uint8(bytes, it) << 24 >> 24;
  }
  function uint8(bytes, it) {
  	return bytes[it.offset++];
  }
  function int16(bytes, it) {
  	return uint16(bytes, it) << 16 >> 16;
  }
  function uint16(bytes, it) {
  	return bytes[it.offset++] | bytes[it.offset++] << 8;
  }
  function int32(bytes, it) {
  	return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;
  }
  function uint32(bytes, it) {
  	return int32(bytes, it) >>> 0;
  }
  function int64(bytes, it) {
  	const low = uint32(bytes, it);
  	const high = int32(bytes, it) * Math.pow(2, 32);
  	return high + low;
  }
  function uint64(bytes, it) {
  	const low = uint32(bytes, it);
  	const high = uint32(bytes, it) * Math.pow(2, 32);
  	return high + low;
  }const _int32 = new Int32Array(2);
  const _float32 = new Float32Array(_int32.buffer);
  const _float64 = new Float64Array(_int32.buffer);
 
  function readFloat32(bytes, it) {
  	_int32[0] = int32(bytes, it);
  	return _float32[0];
  }
  function readFloat64(bytes, it) {
  	_int32[0 ] = int32(bytes, it);
  	_int32[1 ] = int32(bytes, it);
  	return _float64[0];
  }
  function string(bytes, it) {
  	const prefix = bytes[it.offset++];
  	let length;
 
  	if (prefix < 0xc0) {
  		// fixstr
  		length = prefix & 0x1f;
 
  	} else if (prefix === 0xd9) {
  		length = uint8(bytes, it);
 
  	} else if (prefix === 0xda) {
  		length = uint16(bytes, it);
 
  	} else if (prefix === 0xdb) {
  		length = uint32(bytes, it);
  	}
 
  	const value = utf8Read$1(bytes, it.offset, length);
  	it.offset += length;
 
  	return value;
  }
 
  function stringCheck(bytes, it) {
  	const prefix = bytes[it.offset];
  	return (
  		// fixstr
  		(prefix < 0xc0 && prefix > 0xa0) ||
  		// str 8
  		prefix === 0xd9 ||
  		// str 16
  		prefix === 0xda ||
  		// str 32
  		prefix === 0xdb
  	);
  }
 
  function number(bytes, it) {
  	const prefix = bytes[it.offset++];
 
  	if (prefix < 0x80) {
  		// positive fixint
  		return prefix;
 
  	} else if (prefix === 0xca) {
  		// float 32
  		return readFloat32(bytes, it);
 
  	} else if (prefix === 0xcb) {
  		// float 64
  		return readFloat64(bytes, it);
 
  	} else if (prefix === 0xcc) {
  		// uint 8
  		return uint8(bytes, it);
 
  	} else if (prefix === 0xcd) {
  		// uint 16
  		return uint16(bytes, it);
 
  	} else if (prefix === 0xce) {
  		// uint 32
  		return uint32(bytes, it);
 
  	} else if (prefix === 0xcf) {
  		// uint 64
  		return uint64(bytes, it);
 
  	} else if (prefix === 0xd0) {
  		// int 8
  		return int8(bytes, it);
 
  	} else if (prefix === 0xd1) {
  		// int 16
  		return int16(bytes, it);
 
  	} else if (prefix === 0xd2) {
  		// int 32
  		return int32(bytes, it);
 
  	} else if (prefix === 0xd3) {
  		// int 64
  		return int64(bytes, it);
 
  	} else if (prefix > 0xdf) {
  		// negative fixint
  		return (0xff - prefix + 1) * -1
  	}
  }
 
  const Protocol = {
      // Room-related (10~19)
      JOIN_ROOM: 10,
      ERROR: 11,
      LEAVE_ROOM: 12,
      ROOM_DATA: 13,
      ROOM_STATE: 14,
      ROOM_STATE_PATCH: 15,
      ROOM_DATA_SCHEMA: 16
  };
 
  function Decoder(buffer, offset) {
      this._offset = offset;
      if (buffer instanceof ArrayBuffer) {
          this._buffer = buffer;
          this._view = new DataView(this._buffer);
      }
      else if (ArrayBuffer.isView(buffer)) {
          this._buffer = buffer.buffer;
          this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);
      }
      else {
          throw new Error('Invalid argument');
      }
  }
  function utf8Read(view, offset, length) {
      var string = '', chr = 0;
      for (var i = offset, end = offset + length; i < end; i++) {
          var byte = view.getUint8(i);
          if ((byte & 0x80) === 0x00) {
              string += String.fromCharCode(byte);
              continue;
          }
          if ((byte & 0xe0) === 0xc0) {
              string += String.fromCharCode(((byte & 0x1f) << 6) |
                  (view.getUint8(++i) & 0x3f));
              continue;
          }
          if ((byte & 0xf0) === 0xe0) {
              string += String.fromCharCode(((byte & 0x0f) << 12) |
                  ((view.getUint8(++i) & 0x3f) << 6) |
                  ((view.getUint8(++i) & 0x3f) << 0));
              continue;
          }
          if ((byte & 0xf8) === 0xf0) {
              chr = ((byte & 0x07) << 18) |
                  ((view.getUint8(++i) & 0x3f) << 12) |
                  ((view.getUint8(++i) & 0x3f) << 6) |
                  ((view.getUint8(++i) & 0x3f) << 0);
              if (chr >= 0x010000) { // surrogate pair
                  chr -= 0x010000;
                  string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
              }
              else {
                  string += String.fromCharCode(chr);
              }
              continue;
          }
          throw new Error('Invalid byte ' + byte.toString(16));
      }
      return string;
  }
  Decoder.prototype._array = function (length) {
      var value = new Array(length);
      for (var i = 0; i < length; i++) {
          value[i] = this._parse();
      }
      return value;
  };
  Decoder.prototype._map = function (length) {
      var key = '', value = {};
      for (var i = 0; i < length; i++) {
          key = this._parse();
          value[key] = this._parse();
      }
      return value;
  };
  Decoder.prototype._str = function (length) {
      var value = utf8Read(this._view, this._offset, length);
      this._offset += length;
      return value;
  };
  Decoder.prototype._bin = function (length) {
      var value = this._buffer.slice(this._offset, this._offset + length);
      this._offset += length;
      return value;
  };
  Decoder.prototype._parse = function () {
      var prefix = this._view.getUint8(this._offset++);
      var value, length = 0, type = 0, hi = 0, lo = 0;
      if (prefix < 0xc0) {
          // positive fixint
          if (prefix < 0x80) {
              return prefix;
          }
          // fixmap
          if (prefix < 0x90) {
              return this._map(prefix & 0x0f);
          }
          // fixarray
          if (prefix < 0xa0) {
              return this._array(prefix & 0x0f);
          }
          // fixstr
          return this._str(prefix & 0x1f);
      }
      // negative fixint
      if (prefix > 0xdf) {
          return (0xff - prefix + 1) * -1;
      }
      switch (prefix) {
          // nil
          case 0xc0:
              return null;
          // false
          case 0xc2:
              return false;
          // true
          case 0xc3:
              return true;
          // bin
          case 0xc4:
              length = this._view.getUint8(this._offset);
              this._offset += 1;
              return this._bin(length);
          case 0xc5:
              length = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._bin(length);
          case 0xc6:
              length = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._bin(length);
          // ext
          case 0xc7:
              length = this._view.getUint8(this._offset);
              type = this._view.getInt8(this._offset + 1);
              this._offset += 2;
              return [type, this._bin(length)];
          case 0xc8:
              length = this._view.getUint16(this._offset);
              type = this._view.getInt8(this._offset + 2);
              this._offset += 3;
              return [type, this._bin(length)];
          case 0xc9:
              length = this._view.getUint32(this._offset);
              type = this._view.getInt8(this._offset + 4);
              this._offset += 5;
              return [type, this._bin(length)];
          // float
          case 0xca:
              value = this._view.getFloat32(this._offset);
              this._offset += 4;
              return value;
          case 0xcb:
              value = this._view.getFloat64(this._offset);
              this._offset += 8;
              return value;
          // uint
          case 0xcc:
              value = this._view.getUint8(this._offset);
              this._offset += 1;
              return value;
          case 0xcd:
              value = this._view.getUint16(this._offset);
              this._offset += 2;
              return value;
          case 0xce:
              value = this._view.getUint32(this._offset);
              this._offset += 4;
              return value;
          case 0xcf:
              hi = this._view.getUint32(this._offset) * Math.pow(2, 32);
              lo = this._view.getUint32(this._offset + 4);
              this._offset += 8;
              return hi + lo;
          // int
          case 0xd0:
              value = this._view.getInt8(this._offset);
              this._offset += 1;
              return value;
          case 0xd1:
              value = this._view.getInt16(this._offset);
              this._offset += 2;
              return value;
          case 0xd2:
              value = this._view.getInt32(this._offset);
              this._offset += 4;
              return value;
          case 0xd3:
              hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
              lo = this._view.getUint32(this._offset + 4);
              this._offset += 8;
              return hi + lo;
          // fixext
          case 0xd4:
              type = this._view.getInt8(this._offset);
              this._offset += 1;
              if (type === 0x00) {
                  this._offset += 1;
                  return void 0;
              }
              return [type, this._bin(1)];
          case 0xd5:
              type = this._view.getInt8(this._offset);
              this._offset += 1;
              return [type, this._bin(2)];
          case 0xd6:
              type = this._view.getInt8(this._offset);
              this._offset += 1;
              return [type, this._bin(4)];
          case 0xd7:
              type = this._view.getInt8(this._offset);
              this._offset += 1;
              if (type === 0x00) {
                  hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
                  lo = this._view.getUint32(this._offset + 4);
                  this._offset += 8;
                  return new Date(hi + lo);
              }
              return [type, this._bin(8)];
          case 0xd8:
              type = this._view.getInt8(this._offset);
              this._offset += 1;
              return [type, this._bin(16)];
          // str
          case 0xd9:
              length = this._view.getUint8(this._offset);
              this._offset += 1;
              return this._str(length);
          case 0xda:
              length = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._str(length);
          case 0xdb:
              length = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._str(length);
          // array
          case 0xdc:
              length = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._array(length);
          case 0xdd:
              length = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._array(length);
          // map
          case 0xde:
              length = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._map(length);
          case 0xdf:
              length = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._map(length);
      }
      throw new Error('Could not parse');
  };
  function decode$1(buffer, offset) {
      if (offset === void 0) { offset = 0; }
      var decoder = new Decoder(buffer, offset);
      var value = decoder._parse();
      if (decoder._offset !== buffer.byteLength) {
          throw new Error((buffer.byteLength - decoder._offset) + ' trailing bytes');
      }
      return value;
  }
  //
  // ENCODER
  //
  function utf8Write(view, offset, str) {
      var c = 0;
      for (var i = 0, l = str.length; i < l; i++) {
          c = str.charCodeAt(i);
          if (c < 0x80) {
              view.setUint8(offset++, c);
          }
          else if (c < 0x800) {
              view.setUint8(offset++, 0xc0 | (c >> 6));
              view.setUint8(offset++, 0x80 | (c & 0x3f));
          }
          else if (c < 0xd800 || c >= 0xe000) {
              view.setUint8(offset++, 0xe0 | (c >> 12));
              view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
              view.setUint8(offset++, 0x80 | (c & 0x3f));
          }
          else {
              i++;
              c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
              view.setUint8(offset++, 0xf0 | (c >> 18));
              view.setUint8(offset++, 0x80 | (c >> 12) & 0x3f);
              view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
              view.setUint8(offset++, 0x80 | (c & 0x3f));
          }
      }
  }
  function utf8Length(str) {
      var c = 0, length = 0;
      for (var i = 0, l = str.length; i < l; i++) {
          c = str.charCodeAt(i);
          if (c < 0x80) {
              length += 1;
          }
          else if (c < 0x800) {
              length += 2;
          }
          else if (c < 0xd800 || c >= 0xe000) {
              length += 3;
          }
          else {
              i++;
              length += 4;
          }
      }
      return length;
  }
  function _encode(bytes, defers, value) {
      var type = typeof value, i = 0, l = 0, hi = 0, lo = 0, length = 0, size = 0;
      if (type === 'string') {
          length = utf8Length(value);
          // fixstr
          if (length < 0x20) {
              bytes.push(length | 0xa0);
              size = 1;
          }
          // str 8
          else if (length < 0x100) {
              bytes.push(0xd9, length);
              size = 2;
          }
          // str 16
          else if (length < 0x10000) {
              bytes.push(0xda, length >> 8, length);
              size = 3;
          }
          // str 32
          else if (length < 0x100000000) {
              bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);
              size = 5;
          }
          else {
              throw new Error('String too long');
          }
          defers.push({ _str: value, _length: length, _offset: bytes.length });
          return size + length;
      }
      if (type === 'number') {
          // TODO: encode to float 32?
          // float 64
          if (Math.floor(value) !== value || !isFinite(value)) {
              bytes.push(0xcb);
              defers.push({ _float: value, _length: 8, _offset: bytes.length });
              return 9;
          }
          if (value >= 0) {
              // positive fixnum
              if (value < 0x80) {
                  bytes.push(value);
                  return 1;
              }
              // uint 8
              if (value < 0x100) {
                  bytes.push(0xcc, value);
                  return 2;
              }
              // uint 16
              if (value < 0x10000) {
                  bytes.push(0xcd, value >> 8, value);
                  return 3;
              }
              // uint 32
              if (value < 0x100000000) {
                  bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);
                  return 5;
              }
              // uint 64
              hi = (value / Math.pow(2, 32)) >> 0;
              lo = value >>> 0;
              bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
              return 9;
          }
          else {
              // negative fixnum
              if (value >= -0x20) {
                  bytes.push(value);
                  return 1;
              }
              // int 8
              if (value >= -0x80) {
                  bytes.push(0xd0, value);
                  return 2;
              }
              // int 16
              if (value >= -0x8000) {
                  bytes.push(0xd1, value >> 8, value);
                  return 3;
              }
              // int 32
              if (value >= -0x80000000) {
                  bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);
                  return 5;
              }
              // int 64
              hi = Math.floor(value / Math.pow(2, 32));
              lo = value >>> 0;
              bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
              return 9;
          }
      }
      if (type === 'object') {
          // nil
          if (value === null) {
              bytes.push(0xc0);
              return 1;
          }
          if (Array.isArray(value)) {
              length = value.length;
              // fixarray
              if (length < 0x10) {
                  bytes.push(length | 0x90);
                  size = 1;
              }
              // array 16
              else if (length < 0x10000) {
                  bytes.push(0xdc, length >> 8, length);
                  size = 3;
              }
              // array 32
              else if (length < 0x100000000) {
                  bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);
                  size = 5;
              }
              else {
                  throw new Error('Array too large');
              }
              for (i = 0; i < length; i++) {
                  size += _encode(bytes, defers, value[i]);
              }
              return size;
          }
          // fixext 8 / Date
          if (value instanceof Date) {
              var time = value.getTime();
              hi = Math.floor(time / Math.pow(2, 32));
              lo = time >>> 0;
              bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
              return 10;
          }
          if (value instanceof ArrayBuffer) {
              length = value.byteLength;
              // bin 8
              if (length < 0x100) {
                  bytes.push(0xc4, length);
                  size = 2;
              }
              else
              // bin 16
              if (length < 0x10000) {
                  bytes.push(0xc5, length >> 8, length);
                  size = 3;
              }
              else
              // bin 32
              if (length < 0x100000000) {
                  bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);
                  size = 5;
              }
              else {
                  throw new Error('Buffer too large');
              }
              defers.push({ _bin: value, _length: length, _offset: bytes.length });
              return size + length;
          }
          if (typeof value.toJSON === 'function') {
              return _encode(bytes, defers, value.toJSON());
          }
          var keys = [], key = '';
          var allKeys = Object.keys(value);
          for (i = 0, l = allKeys.length; i < l; i++) {
              key = allKeys[i];
              if (typeof value[key] !== 'function') {
                  keys.push(key);
              }
          }
          length = keys.length;
          // fixmap
          if (length < 0x10) {
              bytes.push(length | 0x80);
              size = 1;
          }
          // map 16
          else if (length < 0x10000) {
              bytes.push(0xde, length >> 8, length);
              size = 3;
          }
          // map 32
          else if (length < 0x100000000) {
              bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);
              size = 5;
          }
          else {
              throw new Error('Object too large');
          }
          for (i = 0; i < length; i++) {
              key = keys[i];
              size += _encode(bytes, defers, key);
              size += _encode(bytes, defers, value[key]);
          }
          return size;
      }
      // false/true
      if (type === 'boolean') {
          bytes.push(value ? 0xc3 : 0xc2);
          return 1;
      }
      // fixext 1 / undefined
      if (type === 'undefined') {
          bytes.push(0xd4, 0, 0);
          return 3;
      }
      throw new Error('Could not encode');
  }
  function encode$1(value) {
      var bytes = [];
      var defers = [];
      var size = _encode(bytes, defers, value);
      var buf = new ArrayBuffer(size);
      var view = new DataView(buf);
      var deferIndex = 0;
      var deferWritten = 0;
      var nextOffset = -1;
      if (defers.length > 0) {
          nextOffset = defers[0]._offset;
      }
      var defer, deferLength = 0, offset = 0;
      for (var i = 0, l = bytes.length; i < l; i++) {
          view.setUint8(deferWritten + i, bytes[i]);
          if (i + 1 !== nextOffset) {
              continue;
          }
          defer = defers[deferIndex];
          deferLength = defer._length;
          offset = deferWritten + nextOffset;
          if (defer._bin) {
              var bin = new Uint8Array(defer._bin);
              for (var j = 0; j < deferLength; j++) {
                  view.setUint8(offset + j, bin[j]);
              }
          }
          else if (defer._str) {
              utf8Write(view, offset, defer._str);
          }
          else if (defer._float !== undefined) {
              view.setFloat64(offset, defer._float);
          }
          deferIndex++;
          deferWritten += deferLength;
          if (defers[deferIndex]) {
              nextOffset = defers[deferIndex]._offset;
          }
      }
      return buf;
  }
 
  function decodeExport(packet) {
      const u8arr = new Uint8Array(packet);
      const bytes = Array.from(u8arr);
      const prefix = bytes[0];
 
      if(prefix == Protocol.ROOM_DATA) {
          let it = { offset: 1 };
 
          stringCheck(bytes, it) ? string(bytes, it) : number(bytes, it);
          let parsed = decode$1(packet, it.offset);
          return parsed
      } else {
          return null; // hopefully isn't important lol
      }
  }
 
  function encodeExport(channel, packet) {
      let header = [Protocol.ROOM_DATA];
      let channelEncoded = encode$1(channel);
      let packetEncoded = encode$1(packet);
 
      // combine the arraybuffers
      let combined = new Uint8Array(channelEncoded.byteLength + packetEncoded.byteLength + header.length);
      combined.set(header);
      combined.set(new Uint8Array(channelEncoded), header.length);
      combined.set(new Uint8Array(packetEncoded), header.length + channelEncoded.byteLength);
 
      return combined.buffer
  }
 
  var colyseus = {
      decode: decodeExport,
      encode: encodeExport
  };
 
  // this code was stolen from the original Gimkit Util extension
  function n(t, e, n) {
      for (var i = 0, s = 0, o = n.length; s < o; s++)(i = n.charCodeAt(s)) < 128 ? t.setUint8(e++, i) : (i < 2048 ? t.setUint8(e++, 192 | i >> 6) : (i < 55296 || 57344 <= i ? t.setUint8(e++, 224 | i >> 12) : (s++, i = 65536 + ((1023 & i) << 10 | 1023 & n.charCodeAt(s)), t.setUint8(e++, 240 | i >> 18), t.setUint8(e++, 128 | i >> 12 & 63)), t.setUint8(e++, 128 | i >> 6 & 63)), t.setUint8(e++, 128 | 63 & i));
  }
 
  function encode(t, e, s) {
      const o = {
          type: 2,
          data: ["blueboat_SEND_MESSAGE", {
              room: s,
              key: t,
              data: e
          }],
          options: {
              compress: !0
          },
          nsp: "/"
      };
      return function(t) {
          var e = [],
              i = [],
              s = function t(e, n, i) {
                  var s = typeof i,
                      o = 0,
                      r = 0,
                      a = 0,
                      c = 0,
                      l = 0,
                      u = 0;
                  if ("string" === s) {
                      if ((l = function(t) {
                              for (var e = 0, n = 0, i = 0, s = t.length; i < s; i++)(e = t.charCodeAt(i)) < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || 57344 <= e ? n += 3 : (i++, n += 4);
                              return n
                          }(i)) < 32) e.push(160 | l), u = 1;
                      else if (l < 256) e.push(217, l), u = 2;
                      else if (l < 65536) e.push(218, l >> 8, l), u = 3;
                      else {
                          if (!(l < 4294967296)) throw new Error("String too long");
                          e.push(219, l >> 24, l >> 16, l >> 8, l), u = 5;
                      }
                      return n.push({
                          h: i,
                          u: l,
                          t: e.length
                      }), u + l
                  }
                  if ("number" === s) return Math.floor(i) === i && isFinite(i) ? 0 <= i ? i < 128 ? (e.push(i), 1) : i < 256 ? (e.push(204, i), 2) : i < 65536 ? (e.push(205, i >> 8, i), 3) : i < 4294967296 ? (e.push(206, i >> 24, i >> 16, i >> 8, i), 5) : (a = i / Math.pow(2, 32) >> 0, c = i >>> 0, e.push(207, a >> 24, a >> 16, a >> 8, a, c >> 24, c >> 16, c >> 8, c), 9) : -32 <= i ? (e.push(i), 1) : -128 <= i ? (e.push(208, i), 2) : -32768 <= i ? (e.push(209, i >> 8, i), 3) : -2147483648 <= i ? (e.push(210, i >> 24, i >> 16, i >> 8, i), 5) : (a = Math.floor(i / Math.pow(2, 32)), c = i >>> 0, e.push(211, a >> 24, a >> 16, a >> 8, a, c >> 24, c >> 16, c >> 8, c), 9) : (e.push(203), n.push({
                      o: i,
                      u: 8,
                      t: e.length
                  }), 9);
                  if ("object" === s) {
                      if (null === i) return e.push(192), 1;
                      if (Array.isArray(i)) {
                          if ((l = i.length) < 16) e.push(144 | l), u = 1;
                          else if (l < 65536) e.push(220, l >> 8, l), u = 3;
                          else {
                              if (!(l < 4294967296)) throw new Error("Array too large");
                              e.push(221, l >> 24, l >> 16, l >> 8, l), u = 5;
                          }
                          for (o = 0; o < l; o++) u += t(e, n, i[o]);
                          return u
                      }
                      if (i instanceof Date) {
                          var h = i.getTime();
                          return a = Math.floor(h / Math.pow(2, 32)), c = h >>> 0, e.push(215, 0, a >> 24, a >> 16, a >> 8, a, c >> 24, c >> 16, c >> 8, c), 10
                      }
                      if (i instanceof ArrayBuffer) {
                          if ((l = i.byteLength) < 256) e.push(196, l), u = 2;
                          else if (l < 65536) e.push(197, l >> 8, l), u = 3;
                          else {
                              if (!(l < 4294967296)) throw new Error("Buffer too large");
                              e.push(198, l >> 24, l >> 16, l >> 8, l), u = 5;
                          }
                          return n.push({
                              l: i,
                              u: l,
                              t: e.length
                          }), u + l
                      }
                      if ("function" == typeof i.toJSON) return t(e, n, i.toJSON());
                      var d = [],
                          f = "",
                          p = Object.keys(i);
                      for (o = 0, r = p.length; o < r; o++) "function" != typeof i[f = p[o]] && d.push(f);
                      if ((l = d.length) < 16) e.push(128 | l), u = 1;
                      else if (l < 65536) e.push(222, l >> 8, l), u = 3;
                      else {
                          if (!(l < 4294967296)) throw new Error("Object too large");
                          e.push(223, l >> 24, l >> 16, l >> 8, l), u = 5;
                      }
                      for (o = 0; o < l; o++) u += t(e, n, f = d[o]), u += t(e, n, i[f]);
                      return u
                  }
                  if ("boolean" === s) return e.push(i ? 195 : 194), 1;
                  if ("undefined" === s) return e.push(212, 0, 0), 3;
                  throw new Error("Could not encode")
              }(e, i, t),
              o = new ArrayBuffer(s),
              r = new DataView(o),
              a = 0,
              c = 0,
              l = -1;
          0 < i.length && (l = i[0].t);
          for (var u, h = 0, d = 0, f = 0, p = e.length; f < p; f++)
              if (r.setUint8(c + f, e[f]), f + 1 === l) {
                  if (h = (u = i[a]).u, d = c + l, u.l)
                      for (var g = new Uint8Array(u.l), E = 0; E < h; E++) r.setUint8(d + E, g[E]);
                  else u.h ? n(r, d, u.h) : void 0 !== u.o && r.setFloat64(d, u.o);
                  c += h, i[++a] && (l = i[a].t);
              } let y = Array.from(new Uint8Array(o));
          y.unshift(4);
          return new Uint8Array(y).buffer
      }(o)
  }
 
  function decode(packet) {
      function e(t) {
          if (this.t = 0, t instanceof ArrayBuffer) this.i = t, this.s = new DataView(this.i);
          else {
              if (!ArrayBuffer.isView(t)) return null;
              this.i = t.buffer, this.s = new DataView(this.i, t.byteOffset, t.byteLength);
          }
      }
 
      e.prototype.g = function(t) {
          for (var e = new Array(t), n = 0; n < t; n++) e[n] = this.v();
          return e
      }, e.prototype.M = function(t) {
          for (var e = {}, n = 0; n < t; n++) e[this.v()] = this.v();
          return e
      }, e.prototype.h = function(t) {
          var e = function(t, e, n) {
              for (var i = "", s = 0, o = e, r = e + n; o < r; o++) {
                  var a = t.getUint8(o);
                  if (0 != (128 & a))
                      if (192 != (224 & a))
                          if (224 != (240 & a)) {
                              if (240 != (248 & a)) throw new Error("Invalid byte " + a.toString(16));
                              65536 <= (s = (7 & a) << 18 | (63 & t.getUint8(++o)) << 12 | (63 & t.getUint8(++o)) << 6 | (63 & t.getUint8(++o)) << 0) ? (s -= 65536, i += String.fromCharCode(55296 + (s >>> 10), 56320 + (1023 & s))) : i += String.fromCharCode(s);
                          } else i += String.fromCharCode((15 & a) << 12 | (63 & t.getUint8(++o)) << 6 | (63 & t.getUint8(++o)) << 0);
                  else i += String.fromCharCode((31 & a) << 6 | 63 & t.getUint8(++o));
                  else i += String.fromCharCode(a);
              }
              return i
          }(this.s, this.t, t);
          return this.t += t, e
      }, e.prototype.l = function(t) {
          var e = this.i.slice(this.t, this.t + t);
          return this.t += t, e
      }, e.prototype.v = function() {
          if(!this.s) return null;
          var t, e = this.s.getUint8(this.t++),
              n = 0,
              i = 0,
              s = 0,
              o = 0;
          if (e < 192) return e < 128 ? e : e < 144 ? this.M(15 & e) : e < 160 ? this.g(15 & e) : this.h(31 & e);
          if (223 < e) return -1 * (255 - e + 1);
          switch (e) {
              case 192:
                  return null;
              case 194:
                  return !1;
              case 195:
                  return !0;
              case 196:
                  return n = this.s.getUint8(this.t), this.t += 1, this.l(n);
              case 197:
                  return n = this.s.getUint16(this.t), this.t += 2, this.l(n);
              case 198:
                  return n = this.s.getUint32(this.t), this.t += 4, this.l(n);
              case 199:
                  return n = this.s.getUint8(this.t), i = this.s.getInt8(this.t + 1), this.t += 2, [i, this.l(n)];
              case 200:
                  return n = this.s.getUint16(this.t), i = this.s.getInt8(this.t + 2), this.t += 3, [i, this.l(n)];
              case 201:
                  return n = this.s.getUint32(this.t), i = this.s.getInt8(this.t + 4), this.t += 5, [i, this.l(n)];
              case 202:
                  return t = this.s.getFloat32(this.t), this.t += 4, t;
              case 203:
                  return t = this.s.getFloat64(this.t), this.t += 8, t;
              case 204:
                  return t = this.s.getUint8(this.t), this.t += 1, t;
              case 205:
                  return t = this.s.getUint16(this.t), this.t += 2, t;
              case 206:
                  return t = this.s.getUint32(this.t), this.t += 4, t;
              case 207:
                  return s = this.s.getUint32(this.t) * Math.pow(2, 32), o = this.s.getUint32(this.t + 4), this.t += 8, s + o;
              case 208:
                  return t = this.s.getInt8(this.t), this.t += 1, t;
              case 209:
                  return t = this.s.getInt16(this.t), this.t += 2, t;
              case 210:
                  return t = this.s.getInt32(this.t), this.t += 4, t;
              case 211:
                  return s = this.s.getInt32(this.t) * Math.pow(2, 32), o = this.s.getUint32(this.t + 4), this.t += 8, s + o;
              case 212:
                  return i = this.s.getInt8(this.t), this.t += 1, 0 === i ? void(this.t += 1) : [i, this.l(1)];
              case 213:
                  return i = this.s.getInt8(this.t), this.t += 1, [i, this.l(2)];
              case 214:
                  return i = this.s.getInt8(this.t), this.t += 1, [i, this.l(4)];
              case 215:
                  return i = this.s.getInt8(this.t), this.t += 1, 0 === i ? (s = this.s.getInt32(this.t) * Math.pow(2, 32), o = this.s.getUint32(this.t + 4), this.t += 8, new Date(s + o)) : [i, this.l(8)];
              case 216:
                  return i = this.s.getInt8(this.t), this.t += 1, [i, this.l(16)];
              case 217:
                  return n = this.s.getUint8(this.t), this.t += 1, this.h(n);
              case 218:
                  return n = this.s.getUint16(this.t), this.t += 2, this.h(n);
              case 219:
                  return n = this.s.getUint32(this.t), this.t += 4, this.h(n);
              case 220:
                  return n = this.s.getUint16(this.t), this.t += 2, this.g(n);
              case 221:
                  return n = this.s.getUint32(this.t), this.t += 4, this.g(n);
              case 222:
                  return n = this.s.getUint16(this.t), this.t += 2, this.M(n);
              case 223:
                  return n = this.s.getUint32(this.t), this.t += 4, this.M(n)
          }
          throw new Error("Could not parse")
      };
 
      const q = function(t) {
          var n = new e(t = t.slice(1)),
              i = n.v();
          if (n.t === t.byteLength) return i;
          return null
      }(packet);
 
      return q?.data?.[1];
  }
 
  var blueboat = {
      encode,
      decode
  };
 
  function HexAlphaToRGBA(hex, alpha) {
      let r = parseInt(hex.slice(1, 3), 16);
      let g = parseInt(hex.slice(3, 5), 16);
      let b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
  function RGBAtoHexAlpha(rgba) {
      let [r, g, b, a] = rgba.slice(5, -1).split(",").map(x => parseFloat(x.trim()));
      let hex = `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
      return [hex, a];
  }
  function parseChangePacket(packet) {
      let returnVar = [];
      for (let change of packet.changes) {
          let data = {};
          let keys = change[1].map((index) => packet.values[index]);
          for (let i = 0; i < keys.length; i++) {
              data[keys[i]] = change[2][i];
          }
          returnVar.push({
              id: change[0],
              data
          });
      }
      return returnVar;
  }
 
  // @ts-ignore (can't be bothered to figure out how to import this)
  class SocketHandler extends EventTarget {
      constructor(cheat) {
          super();
          this.socket = null;
          this.hasFired = false;
          this.transportType = "unknown";
          this.blueboatRoomId = null;
          this.cheat = cheat;
      }
      getSocket() {
          let handlerThis = this;
          if (!Object.isFrozen(WebSocket)) {
              // intercept any outgoing socket connections
              WebSocket.prototype._send = WebSocket.prototype.send;
              WebSocket.prototype.send = function (data) {
                  // if the url is a local url, don't intercept it
                  if (this.url.startsWith("ws://localhost"))
                      return this._send(data);
                  handlerThis.registerSocket(this);
                  if (!handlerThis.socket)
                      return;
                  handlerThis.socket._send(data);
                  // attempt to get the room id
                  if (handlerThis.transportType == "blueboat") {
                      let decoded = blueboat.decode(data);
                      if (decoded.roomId)
                          handlerThis.blueboatRoomId = decoded.roomId;
                      if (decoded.room)
                          handlerThis.blueboatRoomId = decoded.room;
                      if (!handlerThis.blueboatRoomId)
                          handlerThis.cheat.log("Room ID: ", handlerThis.blueboatRoomId);
                  }
              };
          }
          else {
              // periodically attempt to extract the socket, in case something failed
              let tryGetSocket = setInterval(() => {
                  var _a, _b, _c, _d, _e;
                  let gotSocket = (_e = (_d = (_c = (_b = (_a = window === null || window === void 0 ? void 0 : window.stores) === null || _a === void 0 ? void 0 : _a.network) === null || _b === void 0 ? void 0 : _b.room) === null || _c === void 0 ? void 0 : _c.connection) === null || _d === void 0 ? void 0 : _d.transport) === null || _e === void 0 ? void 0 : _e.ws;
                  if (gotSocket) {
                      handlerThis.registerSocket(gotSocket);
                      clearInterval(tryGetSocket);
                  }
              }, 100);
          }
      }
      registerSocket(socket) {
          if (this.hasFired)
              return;
          this.socket = socket;
          this.hasFired = true;
          this.dispatchEvent(new CustomEvent("socket", { detail: socket }));
          // detect the transport type
          if ("stores" in unsafeWindow)
              this.transportType = "colyseus";
          else
              this.transportType = "blueboat";
          let handlerThis = this;
          socket.addEventListener("message", (e) => {
              // decode the message
              let decoded;
              if (this.transportType == "colyseus")
                  decoded = colyseus.decode(e.data);
              else
                  decoded = blueboat.decode(e.data);
              if (!decoded)
                  return;
              handlerThis.dispatchEvent(new CustomEvent("recieveMessage", { detail: decoded }));
              if (typeof decoded != "object")
                  return;
              if ('changes' in decoded) {
                  let parsed = parseChangePacket(decoded);
                  handlerThis.dispatchEvent(new CustomEvent("recieveChanges", { detail: parsed }));
              }
          });
      }
      sendData(channel, data) {
          if (!this.socket)
              return;
          if (!this.blueboatRoomId && this.transportType == "blueboat")
              return this.cheat.log("Room ID not found, can't send data");
          let encoded;
          if (this.transportType == "colyseus")
              encoded = colyseus.encode(channel, data);
          else
              encoded = blueboat.encode(channel, data, this.blueboatRoomId);
          this.socket.send(encoded);
      }
  }
 
  class KeybindManager {
      constructor() {
          this.keys = new Set();
          this.binds = [];
          this.addListeners();
      }
      addListeners() {
          window.addEventListener("keydown", (e) => {
              this.keys.add(e.key.toLowerCase());
              this.checkBinds(e);
          });
          window.addEventListener("keyup", (e) => {
              this.keys.delete(e.key.toLowerCase());
          });
          window.addEventListener("blur", () => {
              this.keys.clear();
          });
      }
      checkBinds(e) {
          var _a;
          if (e.repeat)
              return;
          for (let bind of this.binds) {
              if (!bind.keys.has(e.key.toLowerCase()))
                  continue;
              if (bind.keys.size == 0)
                  continue;
              // if the bind is exclusive, make sure no other keys are pressed
              if (bind.exclusive && bind.keys.size != this.keys.size)
                  continue;
              // check whether the keys in the bind are pressed
              if (Array.from(bind.keys).every(key => this.keys.has(key))) {
                  (_a = bind.callback) === null || _a === void 0 ? void 0 : _a.call(bind);
              }
          }
      }
      registerBind(bind) {
          if (this.binds.includes(bind))
              return;
          this.binds.push(bind);
      }
      removeBind(bind) {
          if (!this.binds.includes(bind))
              return;
          this.binds.splice(this.binds.indexOf(bind), 1);
      }
      clearBinds() {
          this.binds = [];
      }
  }
 
  var css = "#gc_hud {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    z-index: 999999999999;\r\n    pointer-events: none;\r\n    color: var(--text-color);\r\n}\r\n\r\n#gc_hud .menu_controls {\r\n    width: 100%;\r\n    height: 20px;\r\n    background-color: var(--menu-controls-bg-color);\r\n    color: var(--menu-controls-text-color);\r\n    border-radius: 5px 5px 0px 0px;\r\n    text-align: center;\r\n    position: relative;\r\n}\r\n\r\n#gc_hud .menu_minimizer {\r\n    margin-left: 20px;\r\n    margin-right: 20px;\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    user-select: none;\r\n}\r\n\r\n#gc_hud .menu {\r\n    pointer-events: auto;\r\n    position: absolute;\r\n    background-color: var(--menu-bg-color);\r\n    display: inline-block;\r\n    border-radius: 5px;\r\n    overflow-x: hidden;\r\n    overflow-y: hidden;\r\n    resize: both;\r\n    width: 300px;\r\n    height: 200px;\r\n    outline: 3px solid var(--menu-border-color);\r\n}\r\n\r\n#gc_hud .menu.minimized {\r\n    height: 20px !important;\r\n    overflow-y: hidden;\r\n    resize: horizontal;\r\n}\r\n\r\n#gc_hud .group {\r\n    margin: 0px;\r\n    padding: 0px;\r\n    width: 100%;\r\n    /* allocate some space at the top and bottom */\r\n    height: calc(100% - 40px); \r\n    position: absolute;\r\n    top: 20px;\r\n    left: 0;\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: flex-start;\r\n    align-items: center;\r\n    overflow-y: auto;\r\n    overflow-x: hidden;\r\n}\r\n\r\n#gc_hud .button, #gc_hud .group_opener {\r\n    background-color: var(--button-bg-color);\r\n    border: 1px solid var(--button-border-color);\r\n}\r\n\r\n#gc_hud .toggle {\r\n    background-color: var(--toggle-bg-color);\r\n    border: 1px solid var(--toggle-border-color);\r\n}\r\n\r\n#gc_hud .button, #gc_hud .toggle, #gc_hud .group_opener {\r\n    border-radius: 5px;\r\n    padding: 5px;\r\n    margin: 5px;\r\n    cursor: pointer;\r\n    width: 90%;\r\n    transition: transform 0.2s ease-in-out;\r\n}\r\n\r\n/* make it bounce smaller when clicked */\r\n#gc_hud .button:active, #gc_hud .toggle:active, #gc_hud .group_opener:active {\r\n    transform: scale(0.93);\r\n}\r\n\r\n#gc_hud .colorpicker {\r\n    width: 100%;\r\n}\r\n\r\n#gc_hud .colorpicker_wrapper {\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: row;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n    margin: 5px;\r\n}\r\n\r\n#gc_hud .colorpicker_opacity_wrapper {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n}\r\n\r\n#gc_hud .colorpicker_preview {\r\n    width: 50px;\r\n    height: 50px;\r\n    border-radius: 5px;\r\n    opacity: 1;\r\n}\r\n\r\n#gc_hud .text {\r\n    text-align: center;\r\n    width: 100%;\r\n}\r\n\r\n#gc_hud .textinput_wrapper, #gc_hud .dropdown_wrapper, #gc_hud .slider_wrapper {\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n}\r\n\r\n#gc_hud .textinput {\r\n    width: 90%;\r\n    border-radius: 5px;\r\n    border: 1px solid var(--textinput-border-color);\r\n    background-color: var(--textinput-bg-color);\r\n    color: var(--text-color);\r\n    padding: 5px;\r\n    margin: 5px;\r\n}\r\n\r\n#gc_hud .dropdown {\r\n    width: 90%;\r\n    border-radius: 5px;\r\n    border: 1px solid var(--dropdown-border-color);\r\n    background-color: var(--dropdown-bg-color);\r\n    color: var(--text-color);\r\n    padding: 5px;\r\n    margin: 5px;\r\n}\r\n\r\n#gc_hud .toggle_wrapper, #gc_hud .button_wrapper {\r\n    width: 90%;\r\n    display: flex;\r\n    flex-direction: row;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n    padding: 0px;\r\n}\r\n\r\n#gc_hud .toggle, #gc_hud .button {\r\n    /* make it take up as much space as possible */\r\n    width: 100%;\r\n    margin-left: 0px;\r\n    margin-right: 0px;\r\n}\r\n\r\n#gc_hud .keybind_opener {\r\n    width: 30px;\r\n    height: 30px;\r\n    font-size: 30px;\r\n    margin-left: 10px;\r\n}\r\n\r\n#gc_hud .keybind_editor_wrapper {\r\n    background-color: var(--keybind-editor-bg-color);\r\n    border: 3px solid var(--keybind-editor-border-color);\r\n    border-radius: 8px;\r\n}\r\n\r\n#gc_hud .keybind_editor {\r\n    width: 50vw;\r\n    height: 50vh;\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n    color: var(--text-color);\r\n}\r\n\r\n#gc_hud .close {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    width: 20px;\r\n    height: 20px;\r\n    font-size: 20px;\r\n    cursor: pointer;\r\n    user-select: none;\r\n}\r\n\r\n#gc_hud .keybind_title {\r\n    font-size: 40px;\r\n    text-align: center;\r\n}\r\n\r\n#gc_hud .keybind_controls {\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: row;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n}\r\n\r\n#gc_hud .keybind_display {\r\n    border: 3px solid white;\r\n    min-width: 300px;\r\n    border-radius: 5px;\r\n    height: 50px;\r\n    text-align: center;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    cursor: pointer;\r\n}\r\n\r\n#gc_hud .keybind_exclusive {\r\n    display: flex;\r\n}\r\n\r\n#gc_hud .keybind_exclusive .text {\r\n    margin-right: 10px;\r\n}\r\n\r\n#gc_hud .keybind_editor .action {\r\n    cursor: pointer;\r\n}\r\n\r\n#gc_hud .slider {\r\n    width: 90%;\r\n    margin: 5px;\r\n}\r\n\r\n.gc_overlay_canvas {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100vw;\r\n    height: 100vh;\r\n    z-index: 9999;\r\n    pointer-events: none;\r\n}\r\n\r\n@keyframes slide_out_left {\r\n    0% {\r\n        transform: translateX(0);\r\n        opacity: 1;\r\n        pointer-events: all;\r\n    }\r\n\r\n    100% {\r\n        transform: translateX(-100%);\r\n        opacity: 0;\r\n        pointer-events: none;\r\n    }\r\n}\r\n\r\n@keyframes slide_out_right {\r\n    0% {\r\n        transform: translateX(0);\r\n        opacity: 1;\r\n        pointer-events: all;\r\n    }\r\n\r\n    100% {\r\n        transform: translateX(100%);\r\n        opacity: 0;\r\n        pointer-events: none;\r\n    }\r\n}\r\n\r\n@keyframes slide_in_left {\r\n    0% {\r\n        transform: translateX(-100%);\r\n        opacity: 0;\r\n        pointer-events: none;\r\n    }\r\n\r\n    100% {\r\n        transform: translateX(0);\r\n        opacity: 1;\r\n        pointer-events: all;\r\n    }\r\n}\r\n\r\n@keyframes slide_in_right {\r\n    0% {\r\n        transform: translateX(100%);\r\n        opacity: 0;\r\n        pointer-events: none;\r\n    }\r\n\r\n    100% {\r\n        transform: translateX(0);\r\n        opacity: 1;\r\n        pointer-events: all;\r\n    }\r\n}\r\n\r\n@keyframes idle {}";
 
  class HudElement extends EventTarget {
      // any is used to avoid circular dependencies
      constructor(group, options) {
          super();
          this.group = null;
          this.options = null;
          this.element = null;
          this.type = 'element';
          this.group = group;
          this.options = options;
      }
      remove() {
          var _a;
          (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
          this.group.elements.splice(this.group.elements.indexOf(this), 1);
      }
  }
 
  class Text extends HudElement {
      constructor(group, options) {
          super(group, options);
          this.type 
